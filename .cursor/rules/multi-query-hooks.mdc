---
description: When data from multiple queries needs to be combined, transformed, and used across components without re-calculation
alwaysApply: false
---

# Multi-Query Hooks Pattern

This rule defines the standard pattern for creating React hooks that combine data from multiple TanStack Query queries. The primary pattern uses individual `useQuery` calls with `useMemo` for data transformation, as demonstrated in `useTimingObjects`.

## Overview

When a hook needs data from multiple database queries to perform complex operations or transformations, use the individual `useQuery` pattern with `useMemo` for data transformation. This pattern ensures proper memoization, loading states, error handling, and type safety.

## Primary Pattern: Individual useQuery with useMemo

### 1. File Organization

- **Location**: Place multi-query hooks in `src/hooks/` directory
- **Naming**: Use descriptive names like `use[Entity][Action]` (e.g., `useTimingObjects`, `useMarcherVisualGroups`)
- **Exports**: Export the hook function and any utility functions

### 2. Type Definitions

```typescript
// Define the return type for the hook
export type [HookName]Return = {
    // Define all data properties
    dataProperty1: Type1[];
    dataProperty2: Type2;
    // Always include loading and error states
    isLoading: boolean;
    hasError: boolean;
    // Include refresh function if needed
    fetchData?: () => void;
};
```

### 3. Data Processing Function

```typescript
// Extract data transformation logic into a separate function
const process[HookName]Data = (
    data1: DatabaseType1[],
    data2: DatabaseType2[],
    data3: DatabaseType3,
): { processed1: Type1[]; processed2: Type2[] } => {
    // Perform all data transformations here
    const processed1 = data1
        .sort((a, b) => a.position - b.position)
        .map((item, index) => transformItem(item, index));

    const processed2 = data2.map(item =>
        transformWithDependencies(item, processed1)
    );

    return { processed1, processed2 };
};
```

### 4. Hook Implementation Pattern

```typescript
export const use[HookName] = (): [HookName]Return => {
    // Individual useQuery calls - only subscribe to data you need
    const {
        data: data1,
        isLoading: data1Loading,
        isError: data1Error,
        isSuccess: data1Success,
    } = useQuery(queryOptions1());

    const {
        data: data2,
        isLoading: data2Loading,
        isError: data2Error,
        isSuccess: data2Success,
    } = useQuery(queryOptions2());

    const {
        data: data3,
        isLoading: data3Loading,
        isError: data3Error,
        isSuccess: data3Success,
    } = useQuery(queryOptions3());

    // Combine loading states
    const isLoading = data1Loading || data2Loading || data3Loading;

    // Combine error states
    const hasError = data1Error || data2Error || data3Error;

    // Check if all data is ready
    const isDataReady = data1Success && data2Success && data3Success;

    // Refresh function (optional). Only here for legacy support
    const fetchData = useCallback(() => {
        queryClient.invalidateQueries({
            queryKey: queryOptions1().queryKey,
        });
        queryClient.invalidateQueries({
            queryKey: queryOptions2().queryKey,
        });
        queryClient.invalidateQueries({
            queryKey: queryOptions3().queryKey,
        });
    }, []);

    // Wrap data transformation in useMemo to avoid unnecessary re-runs
    const processedData = useMemo(() => {
        if (
            !isDataReady ||
            !data1 ||
            !data2 ||
            !data3
        ) {
            return {
                processed1: [],
                processed2: [],
            };
        }

        return process[HookName]Data(data1, data2, data3);
    }, [isDataReady, data1, data2, data3]);

    return {
        ...processedData,
        isLoading,
        hasError,
        fetchData, // Optional
    };
};
```

## Key Requirements

### 1. Data Subscription

- **Only subscribe to the data you need**: Use individual `useQuery` calls and destructure only the properties you need (`data`, `isLoading`, `isError`, `isSuccess`)
- **Avoid unnecessary subscriptions**: Don't destructure unused properties like `error`, `refetch`, etc.

### 2. Memoization

- **ALWAYS wrap data transformation in `useMemo`**: This prevents unnecessary re-computations when unrelated state changes
- **Include all dependencies**: List all data dependencies in the `useMemo` dependency array
- **Return early for incomplete data**: Check `isDataReady` and data existence before processing

### 3. Loading States

- **Always provide loading state**: Combine all individual loading states with OR logic
- **Return empty arrays/objects during loading**: Provide sensible defaults that won't break consuming components

### 4. Error Handling

- **Always provide error state**: Combine all individual error states with OR logic
- **Handle partial failures gracefully**: Consider what happens if some queries succeed and others fail

### 5. Data Validation

- **Check data readiness**: Use `isDataReady` boolean to ensure all queries completed successfully
- **Validate data existence**: Check that all required data arrays/objects exist before processing
- **Provide type-safe fallbacks**: Return consistent data structures even when data is unavailable

### 6. Refresh Functionality

- **Include refresh function when needed**: Use `useCallback` to create a stable function reference
- **Invalidate all related queries**: Ensure all queries are refreshed together to maintain data consistency

## Import Requirements

```typescript
import { useQuery } from "@tanstack/react-query";
import { useCallback, useMemo } from "react";
import { queryOptions1, queryOptions2, queryOptions3 } from "./queries";
import { DataType1, DataType2 } from "@/global/classes/DataType";
import { DatabaseType1, DatabaseType2, DatabaseType3 } from "@/db-functions";
import { queryClient } from "@/App";
```

## Real Example: useTimingObjects

The `useTimingObjects` hook demonstrates this pattern perfectly:

```typescript
export const useTimingObjects = (): TimingObjects => {
    // Individual useQuery calls - only subscribe to needed data
    const {
        data: pagesData,
        isLoading: pagesLoading,
        isError: pagesError,
        isSuccess: pagesSuccess,
    } = useQuery(allDatabasePagesQueryOptions());

    const {
        data: measuresData,
        isLoading: measuresLoading,
        isError: measuresError,
        isSuccess: measuresSuccess,
    } = useQuery(allDatabaseMeasuresQueryOptions());

    const {
        data: beatsData,
        isLoading: beatsLoading,
        isError: beatsError,
        isSuccess: beatsSuccess,
    } = useQuery(allDatabaseBeatsQueryOptions());

    const {
        data: utilityData,
        isLoading: utilityLoading,
        isError: utilityError,
        isSuccess: utilitySuccess,
    } = useQuery(getUtilityQueryOptions());

    // Combine states
    const isLoading =
        pagesLoading || measuresLoading || beatsLoading || utilityLoading;
    const hasError = pagesError || measuresError || beatsError || utilityError;
    const isDataReady =
        pagesSuccess && measuresSuccess && beatsSuccess && utilitySuccess;

    // Refresh function
    const fetchTimingObjects = useCallback(() => {
        queryClient.invalidateQueries({
            queryKey: allDatabasePagesQueryOptions().queryKey,
        });
        queryClient.invalidateQueries({
            queryKey: allDatabaseMeasuresQueryOptions().queryKey,
        });
        queryClient.invalidateQueries({
            queryKey: allDatabaseBeatsQueryOptions().queryKey,
        });
        queryClient.invalidateQueries({
            queryKey: getUtilityQueryOptions().queryKey,
        });
    }, []);

    // Memoized data transformation
    const processedData = useMemo(() => {
        if (
            !isDataReady ||
            !pagesData ||
            !measuresData ||
            !beatsData ||
            !utilityData
        ) {
            return {
                beats: [],
                measures: [],
                pages: [],
            };
        }

        return processTimingObjects(
            pagesData,
            measuresData,
            beatsData,
            utilityData,
        );
    }, [isDataReady, pagesData, measuresData, beatsData, utilityData]);

    return {
        ...processedData,
        fetchTimingObjects,
        isLoading,
        hasError,
    };
};
```

## Alternative Pattern: useQueries (Legacy)

For simpler cases where you don't need individual query control, you can use `useQueries`:

```typescript
export const use[HookName] = (): [HookName]Return => {
    return useQueries({
        queries: [
            queryOptions1(),
            queryOptions2(),
            queryOptions3(),
        ],
        // CRITICAL: Use stable function reference, not inline function
        combine: _combine[HookName],
    });
};
```

## Anti-Patterns to Avoid

1. **Missing useMemo**: Data transformations will run on every render
2. **Incomplete data validation**: Can cause runtime errors when data is undefined
3. **Missing loading states**: Components can't show loading indicators
4. **Missing error states**: Components can't handle errors gracefully
5. **Unstable refresh functions**: Use `useCallback` to prevent unnecessary re-renders
6. **Subscribing to unused data**: Only destructure the properties you need from useQuery

## Testing Considerations

- Test loading states by mocking query options to return loading
- Test error states by mocking query options to return errors
- Test data transformation logic with various data combinations
- Test early return conditions (incomplete data)
- Use real query options, not mocks, for integration testing

## Performance Notes

- The `useMemo` function only runs when dependencies change
- Keep transformations efficient and avoid expensive operations
- Individual `useQuery` calls allow for more granular control and better performance
- Use stable references (`useCallback`) to prevent unnecessary re-computations
