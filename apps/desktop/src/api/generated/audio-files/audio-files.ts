/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Editor API V1
 * API for the OpenMarch desktop editor (Clerk-authenticated)
 * OpenAPI spec version: v1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    MutationFunction,
    QueryFunction,
    QueryKey,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    GetApiEditorV1ProductionsProductionIdAudioFiles200,
    PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody,
} from ".././model";

import { customInstance } from "../../editor-client";
import type { ErrorType, BodyType } from "../../editor-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary List audio files
 */
export const getApiEditorV1ProductionsProductionIdAudioFiles = (
    productionId: number,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetApiEditorV1ProductionsProductionIdAudioFiles200>(
        {
            url: `/api/editor/v1/productions/${productionId}/audio_files`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getGetApiEditorV1ProductionsProductionIdAudioFilesQueryKey = (
    productionId: number,
) => {
    return [`/api/editor/v1/productions`, productionId, `audio_files`] as const;
};

export const getGetApiEditorV1ProductionsProductionIdAudioFilesQueryOptions = <
    TData = Awaited<
        ReturnType<typeof getApiEditorV1ProductionsProductionIdAudioFiles>
    >,
    TError = ErrorType<void>,
>(
    productionId: number,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getApiEditorV1ProductionsProductionIdAudioFiles
                >
            >,
            TError,
            TData
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetApiEditorV1ProductionsProductionIdAudioFilesQueryKey(
            productionId,
        );

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<typeof getApiEditorV1ProductionsProductionIdAudioFiles>
        >
    > = ({ signal }) =>
        getApiEditorV1ProductionsProductionIdAudioFiles(
            productionId,
            requestOptions,
            signal,
        );

    return {
        queryKey,
        queryFn,
        enabled: !!productionId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<
            ReturnType<typeof getApiEditorV1ProductionsProductionIdAudioFiles>
        >,
        TError,
        TData
    > & { queryKey: QueryKey };
};

export type GetApiEditorV1ProductionsProductionIdAudioFilesQueryResult =
    NonNullable<
        Awaited<
            ReturnType<typeof getApiEditorV1ProductionsProductionIdAudioFiles>
        >
    >;
export type GetApiEditorV1ProductionsProductionIdAudioFilesQueryError =
    ErrorType<void>;

/**
 * @summary List audio files
 */

export function useGetApiEditorV1ProductionsProductionIdAudioFiles<
    TData = Awaited<
        ReturnType<typeof getApiEditorV1ProductionsProductionIdAudioFiles>
    >,
    TError = ErrorType<void>,
>(
    productionId: number,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getApiEditorV1ProductionsProductionIdAudioFiles
                >
            >,
            TError,
            TData
        >;
        request?: SecondParameter<typeof customInstance>;
    },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
    const queryOptions =
        getGetApiEditorV1ProductionsProductionIdAudioFilesQueryOptions(
            productionId,
            options,
        );

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey;
    };

    return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update audio file
 */
export const patchApiEditorV1ProductionsProductionIdAudioFilesId = (
    productionId: number,
    id: number,
    patchApiEditorV1ProductionsProductionIdAudioFilesIdBody: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/api/editor/v1/productions/${productionId}/audio_files/${id}`,
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            data: patchApiEditorV1ProductionsProductionIdAudioFilesIdBody,
            signal,
        },
        options,
    );
};

export const getPatchApiEditorV1ProductionsProductionIdAudioFilesIdMutationOptions =
    <TError = ErrorType<void>, TContext = unknown>(options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof patchApiEditorV1ProductionsProductionIdAudioFilesId
                >
            >,
            TError,
            {
                productionId: number;
                id: number;
                data: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
            },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    }): UseMutationOptions<
        Awaited<
            ReturnType<
                typeof patchApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >,
        TError,
        {
            productionId: number;
            id: number;
            data: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
        },
        TContext
    > => {
        const mutationKey = [
            "patchApiEditorV1ProductionsProductionIdAudioFilesId",
        ];
        const { mutation: mutationOptions, request: requestOptions } = options
            ? options.mutation &&
              "mutationKey" in options.mutation &&
              options.mutation.mutationKey
                ? options
                : { ...options, mutation: { ...options.mutation, mutationKey } }
            : { mutation: { mutationKey }, request: undefined };

        const mutationFn: MutationFunction<
            Awaited<
                ReturnType<
                    typeof patchApiEditorV1ProductionsProductionIdAudioFilesId
                >
            >,
            {
                productionId: number;
                id: number;
                data: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
            }
        > = (props) => {
            const { productionId, id, data } = props ?? {};

            return patchApiEditorV1ProductionsProductionIdAudioFilesId(
                productionId,
                id,
                data,
                requestOptions,
            );
        };

        return { mutationFn, ...mutationOptions };
    };

export type PatchApiEditorV1ProductionsProductionIdAudioFilesIdMutationResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof patchApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >
    >;
export type PatchApiEditorV1ProductionsProductionIdAudioFilesIdMutationBody =
    BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
export type PatchApiEditorV1ProductionsProductionIdAudioFilesIdMutationError =
    ErrorType<void>;

/**
 * @summary Update audio file
 */
export const usePatchApiEditorV1ProductionsProductionIdAudioFilesId = <
    TError = ErrorType<void>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<
                typeof patchApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >,
        TError,
        {
            productionId: number;
            id: number;
            data: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
        },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
    Awaited<
        ReturnType<typeof patchApiEditorV1ProductionsProductionIdAudioFilesId>
    >,
    TError,
    {
        productionId: number;
        id: number;
        data: BodyType<PatchApiEditorV1ProductionsProductionIdAudioFilesIdBody>;
    },
    TContext
> => {
    return useMutation(
        getPatchApiEditorV1ProductionsProductionIdAudioFilesIdMutationOptions(
            options,
        ),
    );
};
/**
 * @summary Delete audio file
 */
export const deleteApiEditorV1ProductionsProductionIdAudioFilesId = (
    productionId: number,
    id: number,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/api/editor/v1/productions/${productionId}/audio_files/${id}`,
            method: "DELETE",
            signal,
        },
        options,
    );
};

export const getDeleteApiEditorV1ProductionsProductionIdAudioFilesIdMutationOptions =
    <TError = ErrorType<void>, TContext = unknown>(options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId
                >
            >,
            TError,
            { productionId: number; id: number },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    }): UseMutationOptions<
        Awaited<
            ReturnType<
                typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >,
        TError,
        { productionId: number; id: number },
        TContext
    > => {
        const mutationKey = [
            "deleteApiEditorV1ProductionsProductionIdAudioFilesId",
        ];
        const { mutation: mutationOptions, request: requestOptions } = options
            ? options.mutation &&
              "mutationKey" in options.mutation &&
              options.mutation.mutationKey
                ? options
                : { ...options, mutation: { ...options.mutation, mutationKey } }
            : { mutation: { mutationKey }, request: undefined };

        const mutationFn: MutationFunction<
            Awaited<
                ReturnType<
                    typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId
                >
            >,
            { productionId: number; id: number }
        > = (props) => {
            const { productionId, id } = props ?? {};

            return deleteApiEditorV1ProductionsProductionIdAudioFilesId(
                productionId,
                id,
                requestOptions,
            );
        };

        return { mutationFn, ...mutationOptions };
    };

export type DeleteApiEditorV1ProductionsProductionIdAudioFilesIdMutationResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >
    >;

export type DeleteApiEditorV1ProductionsProductionIdAudioFilesIdMutationError =
    ErrorType<void>;

/**
 * @summary Delete audio file
 */
export const useDeleteApiEditorV1ProductionsProductionIdAudioFilesId = <
    TError = ErrorType<void>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<
                typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId
            >
        >,
        TError,
        { productionId: number; id: number },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
    Awaited<
        ReturnType<typeof deleteApiEditorV1ProductionsProductionIdAudioFilesId>
    >,
    TError,
    { productionId: number; id: number },
    TContext
> => {
    return useMutation(
        getDeleteApiEditorV1ProductionsProductionIdAudioFilesIdMutationOptions(
            options,
        ),
    );
};
